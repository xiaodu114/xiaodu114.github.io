<!DOCTYPE html>
<html lang="zh-Hans-CN">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>history 对象 - xiaodu114.github.io</title>
        <meta name="keywords" content="xiaodu114,BOM,浏览器对象模型,history" />
        <meta name="description" content="浏览器对象模型（BOM）之 history 对象" />

        <script src="/p/_/js/main.js"></script>
    </head>

    <body>
        <!-- github访问地址：/p/web/js/base/bom/pages/history.html -->
        <div class="blog-page">
            <h1>history 对象</h1>
            <p>敬请期待</p>
            <script>
                //  history 对象表示当前窗口首次使用以来用户的导航历史记录。因为 history 是 window 的属性，所以每个 window 都有自己的 history 对象。出于安全考虑，这个对象不会暴露用户访问过的 URL，但可以通过它在不知道实际 URL 的情况下前进和后退
            </script>

            <script>
                //  导航

                // // 后退一页
                // history.go(-1);
                // // 前进一页
                // history.go(1);
                // // 前进两页
                // history.go(2);

                // //  go()有两个简写方法：back()和 forward()。顾名思义，这两个方法模拟了浏览器的后退按钮和前进按钮：
                // // 后退一页
                // history.back();
                // // 前进一页
                // history.forward();

                //  注意 如果页面 URL 发生变化，则会在历史记录中生成一个新条目。对于 2009 年以来发布的主流浏览器，这包括改变 URL 的散列值（因此，把 location.hash 设置为一个新值会在这些浏览器的历史记录中增加一条记录）。这个行为常被单页应用程序框架用来模拟前进和后退，这样做是为了不会因导航而触发页面刷新
            </script>

            <script>
                //  历史状态管理

                //  hashchange
                //  window.addEventListener("hashchange", locationHashChanged);

                // let stateObject = { foo: "bar" };
                // history.pushState(stateObject, "My title", "baz.html");
                // window.addEventListener("popstate", (event) => {
                //     let state = event.state;
                //     if (state) {
                //         // 第一个页面加载时状态是 null
                //         processState(state);
                //     }
                // });
                // //  可以通过 history.state 获取当前的状态对象
                // console.log(history.state);
                // //  可以使用 replaceState()并传入与 pushState()同样的前两个参数来更新状态。更新状态不会创建新历史记录，只会覆盖当前状态：
                // history.replaceState({ newFoo: "newBar" }, "New title");

                //  注意 使用 HTML5 状态管理时，要确保通过 pushState()创建的每个“假”URL 背后都对应着服务器上一个真实的物理 URL。否则，单击“刷新”按钮会导致 404 错误。所有单页应用程序（SPA，Single Page Application）框架都必须通过服务器或客户端的某些配置解决这个问题。
            </script>
        </div>
    </body>
</html>
