<!DOCTYPE html>
<html lang="zh-cmn-Hans">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Promise - xiaodu114.github.io</title>
        <meta name="keywords" content="xiaodu114,Promise,手写 Promise,ES5 Promise" />
        <meta name="description" content="关于 Promise 的一切，认识 Promise ，重写 Promise" />

        <script src="/p/_/js/main.js"></script>
    </head>

    <body>
        <!-- github访问地址：/p/web/js/base/promise/index.html -->
        <div class="blog-page">
            <h1>Promise</h1>
            <p><line-code>Promise</line-code>，离不开，真的离不开……那他有何魅力，还是先看看权威的解释吧！</p>
            <ul>
                <li>
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">Promise - JavaScript | MDN</a>
                </li>
                <li>
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener noreferrer">使用 Promise - JavaScript | MDN</a>
                </li>
                <li>
                    <a href="https://zh.javascript.info/promise-basics" target="_blank" rel="noopener noreferrer">Promise - 现代 JavaScript 教程</a>
                </li>
            </ul>
            <h2>Promises/A+</h2>
            <ul>
                <li>
                    <a href="https://promisesaplus.com/" target="_blank" rel="noopener noreferrer">Promises/A+</a>
                </li>
            </ul>
            <h2>Polyfill</h2>
            <ul>
                <li>
                    <a href="https://github.com/zloirock/core-js#ecmascript-promise" target="_blank" rel="noopener noreferrer">core-js 中 Promise 的 Polyfill</a>
                </li>
            </ul>
            <h2>拆解 Promise</h2>
            <p>手写 <line-code>Promise</line-code>之后，感觉这块儿就没啥用了……先放这儿吧，后面删掉</p>
            <h3>状态</h3>
            <ul>
                <li><line-code>pending</line-code>，初始状态</li>
                <li><line-code>fulfilled</line-code>，成功状态</li>
                <li><line-code>rejected</line-code>，失败状态</li>
            </ul>
            <mark-block>
                <p>状态的改变只能是下面的两种情况：</p>
                <p>由<line-code>pending</line-code>到<line-code>fulfilled</line-code></p>
                <p>由<line-code>pending</line-code>到<line-code>rejected</line-code></p>
            </mark-block>
            <h3>构造函数</h3>
            <mark-block>
                <ul>
                    <li>参数只有一个，并且是个方法。之后使用<line-code>executor</line-code>代替</li>
                    <li>在<line-code>Promise</line-code>的<line-code>constructor</line-code>中<strong>立即同步调用</strong> <line-code>executor</line-code>这个方法。</li>
                    <li>
                        <span>调用<line-code>executor</line-code>方法时传入两个方法</span>
                        <ul>
                            <li>方法一：可以回传成功的数据，之后状态由<line-code>pending</line-code>修改为<line-code>fulfilled</line-code></li>
                            <li>方法二：可以回传失败的数据，之后状态由<line-code>pending</line-code>修改为<line-code>rejected</line-code></li>
                        </ul>
                    </li>
                </ul>
            </mark-block>
            <h3>实例方法</h3>
            <h4>then</h4>
            <mark-block>
                <ul>
                    <li>
                        <span>两个参数，都是函数，一个是成功的回调，另一个是失败的回调</span>
                        <ul>
                            <li>都是可选的</li>
                            <li>都是如果传入的不是方法，内部会被替换为一个恒等（抛出异常）函数</li>
                        </ul>
                    </li>
                    <li>返回值是一个新的 Promise 对象，来实现链式调用</li>
                    <li>一个 Promise 可以多次调用 then 方法</li>
                </ul>
            </mark-block>
            <h2>手写 Promise</h2>
            <p>尝试手写<line-code>Promise</line-code></p>
            <h3>ES5 写法</h3>
            <p>让<line-code>ES5</line-code>再次焕发生机，毕竟咱还是念旧的是吧</p>
            <h4>初始形态</h4>
            <p><line-code>Promise</line-code>肯定是一个构造函数，我们使用的时候都是<line-code>new</line-code>的。好的，那我们创建一个</p>
            <ul>
                <li>
                    <p>嗨，你听说了吗？最近<line-code>Promise</line-code>很火，好多人都在用他，市场前景广阔啊！💴💴💴</p>
                </li>
                <li>
                    <p>真的吗？这不是咱的强项嘛，我先弄一个，你看看效果……</p>
                </li>
            </ul>
            <p></p>
            <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
//  第一个版本
function MyPromise() {}
            </pre>
            <h4>构造函数</h4>
            <h5>参数</h5>
            <p>当你<line-code>new Promise</line-code>的时候是否传递参数了呢？肯定传了，要是不传，会报错的。并且还必须是个<line-code>function</line-code>，不然也会报错</p>
            <ul>
                <li>
                    <p>我去，你弄的太松驰了，什么东西都可以弄进去，人家只允许<line-code>function</line-code></p>
                </li>
                <li>
                    <p>😅，你稍等，马上支持上……</p>
                </li>
            </ul>
            <p>知己知彼，方能百战百胜。还是先看看人家是怎么弄的，原生的<line-code>Promise</line-code>是这样的</p>
            <details>
                <summary>点击查看原生 Promise 的行为</summary>
                <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
//  TypeError: Promise resolver undefined is not a function
var p1 = new Promise();

//  TypeError: Promise resolver 666 is not a function
var p2 = new Promise(666);

//  TypeError: Promise resolver #&lt;Object> is not a function
var p2 = new Promise({name:"666"});
                </pre>
            </details>
            <p>咱们的是这样的</p>
            <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
//  如果传入的是 {name:"666"} ，错误信息不一样。毕竟是仿造的，先这样吧！
function MyPromise(executor) {
    if (typeof executor !== "function") throw new TypeError("Promise resolver " + executor + " is not a function");
}
            </pre>
            <mark-block>
                <p>后面的<line-code>Promise</line-code>参数就用<line-code>executor</line-code>代替了！只要提到<line-code>executor</line-code>，就要想到他就是你<line-code>new Promise</line-code>时传进来的实参，他的类型是<line-code>function</line-code></p>
            </mark-block>
            <h5>添加[[PromiseState]]和[[PromiseResult]]</h5>
            <p>既然可以<line-code>new</line-code>成功了，那我们就看一下，他的实例到底是个啥！</p>
            <ul>
                <li>
                    <p>这是什么玩意儿啊！人家<line-code>Promise</line-code>造的，除了有<line-code>[[Prototype]]</line-code>，还有<line-code>[[PromiseState]]</line-code>和<line-code>[[PromiseResult]]</line-code>，你的就只有<line-code>[[Prototype]]</line-code>，你这缺斤少两的，不行，不行，我要退货。</p>
                </li>
                <li>
                    <p>亲爱的上帝，您别急，咱们的毕竟是伪造的，但是终究物美价廉不是，<line-code>[[PromiseState]]</line-code>和<line-code>[[PromiseResult]]</line-code>我们是造不出来，封锁比较严重，你懂的，但是可以给你<line-code>PromiseState</line-code>和<line-code>PromiseResult</line-code>这一对儿，虽然外形有点差异，但是我保证，他们的内在绝对是一样的，你就放心用吧</p>
                </li>
            </ul>
            <p>真不容易啊，还是得先看看人家的。原生的<line-code>Promise</line-code>是这样的</p>
            <details>
                <summary>点击查看原生 Promise 的行为</summary>
                <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
new Promise(()=>{})
                </pre>
                <p>请看正版的输出结果</p>
                <p>
                    <img src="./image/my-001.png" alt="控制台查看 Promise 实例" />
                </p>
            </details>
            <p>咱们的是这样的，您放心绝对不影响你使用，并且终身质保</p>
            <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
function MyPromise(executor) {
    if (typeof executor !== "function") throw new TypeError("Promise resolver " + executor + " is not a function");

    this.PromiseState = "pending";
    this.PromiseResult = undefined;
}
            </pre>
            <h5>立即同步执行 executor</h5>
            <p>咱先对一下暗号，<line-code>executor</line-code>是啥？对，他就是你<line-code>new Promise</line-code>时传进来的实参，并且是个方法</p>
            <ul>
                <li>
                    <p>不行，还是不行，人家的只要一<line-code>new</line-code>，就会给我反馈，你这不行啊，我都试了好多次了</p>
                </li>
                <li>
                    <p>您先别着急，我给您看看……</p>
                </li>
            </ul>
            <p>真不能偷懒啊，还得看看人家的。原生的<line-code>Promise</line-code>是这样的</p>
            <details>
                <summary>点击查看原生 Promise 的行为</summary>
                <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
//  你可以看看输出顺序是什么？
function executor() {
    console.log(1);
}
new Promise(executor);
console.log(2);
                </pre>
            </details>
            <p>咱们的是这样的</p>
            <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
//  咱也得安排上，既然你给了我一个方法，那我就马上调用，绝不迟疑
function MyPromise(executor) {
    if (typeof executor !== "function") throw new TypeError("Promise resolver " + executor + " is not a function");

    this.PromiseState = "pending";
    this.PromiseResult = undefined;

    executor();
}
            </pre>
            <h5>executor 的参数</h5>
            <p>在<line-code>Promise</line-code>内部调用<line-code>executor</line-code>方法时传入了两个参数并且都是方法</p>
            <ul>
                <li>
                    <p>哎，哎，哎，不对呀！我记得人家的<line-code>Promise</line-code>调用<line-code>executor</line-code>时传给了我两个参数呢，你咋没有啊。能不能行了，快点啊，要不退货了啊</p>
                </li>
                <li>
                    <p>您别急啊，先消消气儿，马上给您安排</p>
                </li>
            </ul>
            <p>原生的<line-code>Promise</line-code>是这样的</p>
            <details>
                <summary>点击查看原生 Promise 的行为</summary>
                <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
function executor() {
    console.log("参数长度：", arguments.length);
    for (var i = 0; i &lt; arguments.length; i++) {
        console.log("第" + (i + 1) + "个参数的类型：", typeof arguments[i]);
    }
}
new Promise(executor);
                </pre>
            </details>
            <p>咱们的是这样的</p>
            <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
//  咱也得安排上，你给了我一个方法，那我就给你两个
function MyPromise(executor) {
    if (typeof executor !== "function") throw new TypeError("Promise resolver " + executor + " is not a function");

    this.PromiseState = "pending";
    this.PromiseResult = undefined;

    function resolve() {}
    function reject() {}

    executor(resolve, reject);
}
            </pre>
            <h5>修改[[PromiseState]]和[[PromiseResult]]</h5>
            <p>执行<line-code>executor</line-code>时传入的两个方法就是修改<line-code>[[PromiseState]]</line-code>和<line-code>[[PromiseResult]]</line-code>用的</p>
            <ul>
                <li>你不能这样啊，你给我的两个方法都是摆设啊，我试了好几次了，没反应啊，你在这儿糊弄鬼呢。你看看人家<line-code>Promise</line-code>，只要一按下<line-code>resolve</line-code>，<line-code>[[PromiseState]]</line-code>就变成了"fulfilled"，还有呢，<line-code>[[PromiseResult]]</line-code>还能显示我使了多大劲儿，多神奇啊</li>
                <li>尊敬的用户，你千万别急，我马上为您修复（终于知道那俩方法是干啥的了）</li>
            </ul>
            <p>原生的<line-code>Promise</line-code>是这样的</p>
            <details>
                <summary>点击查看原生 Promise 的行为</summary>
                <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
//  成功示例 1
function executor1(resolve, reject) {
    resolve();
}
new Promise(executor1);
//  成功示例 2
function executor2(resolve, reject) {
    resolve(666, true, { name: "xiaodu114" });
}
new Promise(executor2);
//  失败示例 1
function executor3(resolve, reject) {
    reject();
}
new Promise(executor3);
//  失败示例 2
function executor4(resolve, reject) {
    reject(777, false, { name: "a2bei4" });
}
new Promise(executor4);
                </pre>
            </details>
            <p>咱们的是这样的</p>
            <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
function MyPromise(executor) {
    if (typeof executor !== "function") throw new TypeError("Promise resolver " + executor + " is not a function");

    this.PromiseState = "pending";
    this.PromiseResult = undefined;

    var resolve = function (data) {
        this.PromiseResult = data;
        this.PromiseState = "fulfilled";
    }.bind(this);
    var reject = function (error) {
        this.PromiseResult = error;
        this.PromiseState = "rejected";
    }.bind(this);

    executor(resolve, reject);
}
            </pre>
            <h5>[[PromiseState]]和[[PromiseResult]]只能修改一次</h5>
            <p><line-code>Promise</line-code>还是很专一的，只要确定了一个，就不会改变了。<line-code>[[PromiseState]]</line-code>只能由<line-code>pending</line-code>到<line-code>fulfilled</line-code>或者由<line-code>pending</line-code>到<line-code>rejected</line-code></p>
            <ul>
                <li>
                    <p>哎，哎，哎，你看看人家<line-code>Promise</line-code>，只能是<line-code>pending</line-code>开始，要么<line-code>fulfilled</line-code>，要么<line-code>rejected</line-code>。你别总是那么松弛，咱不是应该先入为主，从一而终嘛！你不能乱来啊</p>
                </li>
                <li>
                    <p>😅，咱也不是那人啊，马上给您解决，虽然质量是差了点，但是咱们的服务是刚刚……</p>
                </li>
            </ul>
            <p>原生的<line-code>Promise</line-code>是这样的</p>
            <details>
                <summary>点击查看原生 Promise 的行为</summary>
                <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
//  示例 1
function executor1(resolve, reject) {
    resolve(666);
    resolve(888);
}
new Promise(executor1);
//  示例 2
function executor2(resolve, reject) {
    reject(555);
    reject(777);
}
new Promise(executor2);
//  示例 3
function executor3(resolve, reject) {
    resolve(666);
    reject(555);
}
new Promise(executor3);
//  示例 4
function executor4(resolve, reject) {
    reject(777);
    resolve(888);
}
new Promise(executor4);
                </pre>
            </details>
            <p>咱们的是这样的</p>
            <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
function MyPromise(executor) {
    if (typeof executor !== "function") throw new TypeError("Promise resolver " + executor + " is not a function");

    this.PromiseState = "pending";
    this.PromiseResult = undefined;

    var resolve = function (data) {
        if (this.PromiseState !== "pending") return;
        this.PromiseResult = data;
        this.PromiseState = "fulfilled";
    }.bind(this);

    var reject = function (error) {
        if (this.PromiseState !== "pending") return;
        this.PromiseResult = error;
        this.PromiseState = "rejected";
    }.bind(this);

    executor(resolve, reject);
}
            </pre>
            <h5>executor 中出现异常</h5>
            <p>你别说<line-code>Promise</line-code>还是很严谨的，考虑的比较全面，比如：执行<line-code>executor</line-code>时报错了怎么办，人家<line-code>try catch</line-code>了</p>
            <ul>
                <li>
                    <p>都给你说了好几遍了，你就是太松驰了，你还不信，你看看人家<line-code>Promise</line-code>执行我传入的<line-code>executor</line-code>时监听异常了，你的就没有，真是太松驰了</p>
                </li>
                <li>
                    <p>（怎么又出问题了，辛亏是个小问题）好滴，好滴，马上给您解决，你就敬听佳音吧！</p>
                </li>
            </ul>
            <p>原生的<line-code>Promise</line-code>是这样的</p>
            <details>
                <summary>点击查看原生 Promise 的行为</summary>
                <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
function executor1(resolve, reject) {
    console.log(a2bei4);
}
new Promise(executor1);
                </pre>
            </details>
            <p>咱们的是这样的</p>
            <pre ddz-class="here-need-to-handle-by-highlight" ddz-lang="javascript">
function MyPromise(executor) {
    if (typeof executor !== "function") throw new TypeError("Promise resolver " + executor + " is not a function");

    this.PromiseState = "pending";
    this.PromiseResult = undefined;

    var resolve = function (data) {
        if (this.PromiseState !== "pending") return;
        this.PromiseResult = data;
        this.PromiseState = "fulfilled";
    }.bind(this);

    var reject = function (error) {
        if (this.PromiseState !== "pending") return;
        this.PromiseResult = error;
        this.PromiseState = "rejected";
    }.bind(this);

    try {
        executor(resolve, reject);
    } catch (error) {
        reject(error);
    }
}
            </pre>
            <h4>then 方法</h4>
            <p>敬请期待</p>
        </div>
    </body>
</html>
